-----------------------------------------------------------------------------
--
-- 6 루아 함수의 내부
-- 
-- 루아 함수는 순수 정적 유효 범위를 지원하며 1급 값으로 취급된다.
-- 이 말은 루아 함수를 숫자나 문자열 등 다른 평범한 값으로 쓸 수 있다는 뜻이다.
-- 함수를 전역, 지역 변수 또는 테이블에 넣을 수 있고, 함수에 인자로 전달할 수 있으며, 반환 받을 수도 있다.
-- '정적 유효 범위'라는 것은 함수 밖에 정의된 변수에 접근할 수 있다는 뜻이다.
--
-- a = {p = print}			
-- a.p("Hello World")		--> Hello World
-- print = math.sin 		--> 'print'는 이제 sin 함수를 참조
-- a.p(print(1))			--> 0.841470
-- sin = a.p 	 			--> 'sin'은 이제 print 함수를 참조
-- sin(10, 20)				--> 10 20
--
-- 함수의 정의문은 '함수'타입의 값을 생성하여 변수에 할당하는 문장이다.
--
-----------------------------------------------------------------------------
--
-- 6.1 클로저
--
-- 함수 안에서 다른 함수를 정의할 때 바깥쪽 함수의 모든 지역 변수를 안쪽에 정의하는 함수에서 쓸 수 있다.
-- 이런 기능을 정적 범위 지정이라 한다.
function newCounter( )
	local i = 0
	return function ( )
				i = i + 1
				return i
			end
end

c1 = newCounter()
print(c1())			--> 1
print(c1())			--> 2
--
-- 이 코드에서 익명 함수가 비지역 변수인 i를 참조하고 있다.
-- 익명 함수가 호출될 무렵에는 변수 i를 가지고 있던 함수 newCounter의 호출이 이미 종료되어
-- 이미 변수 i의 유효 범위를 벗어난 상태이지만, 클로저라는 개념을 지원하기 때문에 가능하다.
--
-- 클로저라는 것은 함수와 그 함수에서 필요로하는 모든 비지역 변수를 포함한 것이라고 할 수 있다.
-- newCounter함수를 다시 호출하면, 새 지역 변수 i를 다시 만들고 이를 새 클로저로 받아 쓰게 된다.
c2 = newCounter()
print(c2())			--> 1
print(c1())			--> 3
print(c2())			--> 2
--
-- c1과 c2는 같음 함수에 대한 다른 클로저가 되고, 각자 지역변수 i로부터 만들어지는 다른 인스턴스처럼 동작한다
--
-- 음 요약해서 정리하자면 위의 i와 같이 익명함수의 지역변수도 아니고, 그렇다고 전역변수도 아닌 
-- 바깥쪽 함수에서 정의되었지만 익명함수에서 사용하는 변수를 비지역 변수라고 하고
-- 외부함수의 실행이 끝나서 외부함수가 소멸된 이후에도 내부함수가 외부함수의 변수(비지역변수)에 접근할 수 있는데 이러한 메커니즘을 클로저라고 한다. 
-- 참고) https://opentutorials.org/course/743/6544
--
function adder(x)
  return function (y) return x + y end
end
a1 = adder(9)
a2 = adder(36)
print(a1(16))  --> 25
print(a2(64))  --> 100
print(a1(21))  --> 30
--
-- 다른 예시로 adder함수가 끝나더라도 a1은 처음 입력한 9를 x가 가지고 있게 된다.
-- 그렇기에 a1(16)을 호출하면 9+16이 호출되어 25가 출력. a1(21)을 호출시 9+21인 30이 출력된다.
-- 만약 함수가 return function (y) x = x +y return x end 의 형태를 가지고 있었다면
-- 첫 a1(16)호출시 25가 출력되고 x는 25가되어 a1(21) 호출시 25+21인 46이 출력된다.
--
-----------------------------------------------------------------------------
--
-- 6.2 비전역 함수
--
-- 루아의 함수는 1급 값으로 전역 변수에 저장할 수 있을 뿐 아니라, 테이블이나 지역 변수에도 저장할 수 있다.
-- 함수를 지역변수에 저장하면 그 함수는 지역 함수가 된다. 즉 유효 범위가 지역으로 제한된다.
-- 주의할 점은 재귀 호출할 때에는 버그를 유발함으로, 지역 변수를 먼저 정의하고 그 다음 함수를 정의하여야 한다.
local fact
fact = function ( n )
	if n == 0 then return 1
	else return n*fact(n-1)
	end
end
-- local fact = function (n)처럼 선언해버리면 fact(n-1)을 컴파일하는 시점에서는
-- 지역 변수인 fact가 아직 정의되기 전이므로, 지역 fact 대신 전역 fact를 호출하도록 해석하여 문제가 발생한다.
-----------------------------------------------------------------------------
--
-- 6.3 꼬리 호출
--
-- 루아 함수의 좋은 점은 꼬리 호출(tail-call)을 제거해 준다는 것이다.
-- 꼬리 호출은 호출의 탈을 쓴 goto와 같다.
-- function f(x) return g(x) end
-- 위의 코드에서 f가 g를 호출하고 난 다음 g를 호출한 지점이 아니라 f를 호출한 지점으로 바로 복귀하는데
-- 루아 인터프리터에서는 꼬리 호출을 위한 추가 스택공간을 사용하지 않는다. (다른언어들은 호출한 함수의 정보를 스택에 남겨둠)
-- 이런 구현을 꼬리 호출 제거(tail-call elimination)라고 한다.
function foo( n )
	if n>0 then
		return foo(n-1)
	end
end
-- 이런 함수에서는 아무 숫자나 인자로 넣어도 스택이 넘치는 경우는 절대 발생하지 않는다.
--
-- funtion f(x) g(x) end
-- return g(x) + 1 			--> 덧셈을 실행해야 함
-- return x or g(x)			--> 두 결과 중 하나만 남겨야 함
-- return (g(x)) 			--> 반환 결과 중 하나만 남겨야 함
--
-- 하지만 위와 같은 코드들은 꼬리 호출이 아니다.
-- return func(arg)의 호출 형태만 꼬리 호출이 될 수 있다.
--
-----------------------------------------------------------------------------

-- 연습문제 생략