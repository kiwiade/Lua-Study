-----------------------------------------------------------------------------
--
-- 7 반복자와 일반 for문
--
-----------------------------------------------------------------------------
--
-- 7.1 반복자와 클로저
--
-- 어떤 콜렉션의 원소를 순회할 수 있게 구성한 코드를 모두 반복자라고 한다.
-- 반복자는 함수를 호출할 때마다 현재 위치가 어딘지, 다음 위치로 어떻게 이동하는지 상태를 저장해야한다.
-- 이런 일에 매우 적합한 방식이 클로저.
-- 
-- 클로저를 구성하기 위해서는 보통 클로저 자신을 표현하는 함수와
-- 클로저와 클로저를 생성하는 팩토리 함수 두 개가 필요하다.
function values( t )
	local i = 0
	return function()
			i = i + 1
			return t[i]
		end
end

t = {10, 20, 30}
iter = values(t)
while true do
	local element = iter()
	if element == nil then
		break
	end
	print(element)
end
-- 
-- 하지만 이렇게 쓰는 것보다는 일반 for문을 쓰는 것이 더 쉬워 보인다.
-- 사실 이 반복자는 다음과 같은 반복문에서 쓰려고 설계한 것이다.
for element in values(t) do
	print(element)
end
--
-- 반복자 함수를 내부에 저장하니 이전 예제의 iter 변수가 필요 없으며,
-- 각 반복마다 반복자를 호출해 주고 반복자가 nil을 반환하면 멈추는 일을 한다.
--
-----------------------------------------------------------------------------
--
-- 7.2 일반 for문의 의미
--
-- 앞 절에서 다룬 반복자의 단점 중 하나는 새 반복문을 시작할 때마다 새 클로저를 생성한다는 점이다.
-- 이런 추가 비용이 미미한 수준이나 비효율적인 상황이 있다.
-- 일반 for문은 아래처럼 사용한다.
--
-- for var-list in exp-list do 
--	body
-- end
--
-- 여기서 var-list는 하나 이상의 변수 이름을 쉼표로 구분해서 나열한 것이고,
-- exp-list는 하나 이상의 표현식을 쉼표로 구분해서 나열한 것을 말한다.
for k, v in pairs(t) do
	print(k,v)
end
--
-- for line in io.lines() do
-- 	io.write(line, "\n")
-- end
--
-- var-list로 나열된 것 중 첫번째 변수를 제어 변수라고 하며, 반복문이 끝나는 경우에만 nil이 된다.
-- 가장 먼저 for문은 in 다음에 오는 표현식들을 계산한다.
-- 이 표현식들을 계산한 결과로는 for문 내부적으로 유지하는 반복자 함수, 불변 상태, 제어변수의 초깃값의 세 값이 나와야한다.
--
-- 표현식을 계산한 값이 3개로 맞춰지므로 남는 값은 버려지고 모자란 값은 nil로 채워진다.
-- 그래서 단순한 반복자를 쓰는 경우, 반복자 함수만 반환하므로 불변상태, 제어변수는 nil이 된다.
--
-- 이런 초기화 단계를 진행한 다음 불변상태와 제어 변수를 인자로 해서 반복자 함수를 호출한다.
-- 그 후 반복자 함수가 반환하는 값을 var-list에서 선언한 변수들에게 할당하고, 
-- 반환된 값 중 처음 것(즉 제어변수)이 nil이면 반복문을 종료한다. nil이 아니면 body부분을 수행한후 다음 반복자 함수를 호출한다.
--
-- for var_1, ..., var_n in explist do block end
-- 의 코드는 아래와 같다
--
-- do
-- 	local _f, _s, _var = explist
-- 	while true do
-- 		local var_1, ..., var_n = _f(_s, _var)
-- 		_var = _var_1
-- 		if _var == nil then
-- 			break
-- 		end
-- 		block
-- 	end
-- end
--
-----------------------------------------------------------------------------
--
-- 7.3 상태가 없는 반복자
--
-- 말 그대로 스스로 유지하고 있는 상태가 전혀 없는 반복자로, 새 클로저를 생성하는 비용을 없앨 수 있다.
-- 배열의 모든 원소에 대해 반복하는 ipairs가 전형적인 예이다.
a = {"one", "two", "three"}
for i, v in ipairs(a) do
	print(i, v)
end
--
-- 이 반복문에서 사용하는 상태는 대상 테이블(불변 상태)과 현재 인덱스(제어 변수)값이다.
local function iter( a, i )
	i = i + 1
	local v = a[i]
	if v then
		return i, v
	end
end

function ipairs( a )
	return iter, a, 0
end
--
-- 반복문에서 ipairs(a)를 호출하면 iter를 반복자로, a를 불변 상태로, 0을 제어 변수의 초깃값으로 얻게 된다.
-- 그 후 iter(a, 0)을 호출해서 1과 a[1]이 결과가 되고, ... 반복하여 첫 값이 nil이 될 때까지 반복한다.
-- 테이블의 모든 원소에 대해 반복하는 pairs도 next함수를 반복자로 반환하는 것 외에는 ipairs와 유사하다.
--
-----------------------------------------------------------------------------
--
-- 7.4 복잡한 반복자
--
-- 반복자를 만들다 보면 불변 상태와 제어 변수 외에도 다른 상태를 유지해야할 필요가 자주 있다.
-- 이 경우 클로저를 사용하는 것이 가장 간단한 해결책이나, 
-- 그 외에도 반복자에 필요한 상태를 테이블에 채워넣고 테이블을 불변 상태로 사용하는 방법도 있다.
-- 되도록이면 for문 자체에 반복에 필요한 것을 저장하는, 상태 없는 반복자를 쓰는 것이 좋다.
-- 
-----------------------------------------------------------------------------
--
-- 7.5 진짜 반복자
--
-- 반복자란 이름에는 오해의 소지가 있다. 왜냐면 실제 반복을 실행하는 것은 for문이지 반복자 함수가 아니기 때문이다.
-- 하지만 반복자를 실제 반복을 실행하는 진짜 반복자로 만드는 대안이 있다.
-- 반복문을 쓰는 대신 반복자에 해야 하는 일을 기술한 인자를 전달하여 호출하면 된다.
--
-- function allwords( f )
-- 	for line in io.lines() do
-- 		for word in string.gmatch(line, "%w+") do
-- 			f(word)
-- 		end
-- 	end
-- end
-- 
-- 각 단어를 출력하려면 간단히 print 함수를 넘기면 된다. allwords(print)
--
-----------------------------------------------------------------------------
--
-- 연습문제 생략...